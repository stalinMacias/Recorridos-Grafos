
import java.awt.List;
import java.awt.TextArea;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

import analizador.Analizador;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Macias
 */
public class MainFrame extends javax.swing.JFrame {

    /**
     * Creat-es new form MainFrame
     */
    static int numNodosGrafo = 0;
    Grafo g;

    //ArrayList para guardar elnombre de los nodos
    ArrayList<String> nombreNodos = new ArrayList<String>();

    boolean asignaranPesos = false;
    boolean asignaranValorHeuristico = false;

    public MainFrame() {
        initComponents();
        this.setLocationRelativeTo(null);
        //Ocultar el panel principal con todos los campos al inicial el programa hasta que el usuario escoja si
        //creará el grafo manualmente o si lo desea cargar desde un archivo de texto!
        mainPanel.setVisible(false);
        textAreaResultados.setVisible(false);
        panelMenu.setVisible(false);
        btnRecorrido.setVisible(false);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelInicial = new javax.swing.JPanel();
        inputOptionCreateGraph = new javax.swing.JTextField();
        btnOptionCreateGraph = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        mainPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        textAreaResultados = new javax.swing.JTextArea();
        lblNumNodos = new javax.swing.JLabel();
        inputNumNodos = new javax.swing.JTextField();
        btnCrearGrafo = new javax.swing.JButton();
        panelMenu = new javax.swing.JPanel();
        inputOpcionMenu = new javax.swing.JTextField();
        btnAceptarOpcion = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        textAreaMenu = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        btnRecorrido = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Grafo usando Listas de Adyacencia");
        setAlwaysOnTop(true);
        setLocation(new java.awt.Point(0, 0));
        setResizable(false);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        inputOptionCreateGraph.setToolTipText("Ingrese 1 para crear el grafo manualmente o 2 para cargar el grafo desde un archivo de texto");

        btnOptionCreateGraph.setText("Aceptar");
        btnOptionCreateGraph.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                btnOptionCreateGraphMousePressed(evt);
            }
        });

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel2.setText("1 para crear el grafo manualmente");
        jLabel2.setToolTipText("");

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel3.setText("2 para cargar el grafo desde un archivo de texto");
        jLabel3.setToolTipText("");

        javax.swing.GroupLayout panelInicialLayout = new javax.swing.GroupLayout(panelInicial);
        panelInicial.setLayout(panelInicialLayout);
        panelInicialLayout.setHorizontalGroup(
            panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelInicialLayout.createSequentialGroup()
                .addContainerGap(600, Short.MAX_VALUE)
                .addComponent(btnOptionCreateGraph, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(200, 200, 200))
            .addGroup(panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panelInicialLayout.createSequentialGroup()
                    .addGap(20, 31, Short.MAX_VALUE)
                    .addGroup(panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 284, Short.MAX_VALUE)
                        .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGap(0, 605, Short.MAX_VALUE)))
            .addGroup(panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panelInicialLayout.createSequentialGroup()
                    .addGap(0, 345, Short.MAX_VALUE)
                    .addComponent(inputOptionCreateGraph, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 345, Short.MAX_VALUE)))
        );
        panelInicialLayout.setVerticalGroup(
            panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelInicialLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(btnOptionCreateGraph, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addGroup(panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panelInicialLayout.createSequentialGroup()
                    .addGap(0, 4, Short.MAX_VALUE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(9, 9, 9)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 5, Short.MAX_VALUE)))
            .addGroup(panelInicialLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panelInicialLayout.createSequentialGroup()
                    .addGap(0, 11, Short.MAX_VALUE)
                    .addComponent(inputOptionCreateGraph, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 11, Short.MAX_VALUE)))
        );

        getContentPane().add(panelInicial, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 920, 60));

        textAreaResultados.setColumns(20);
        textAreaResultados.setRows(5);
        jScrollPane1.setViewportView(textAreaResultados);

        lblNumNodos.setText("Ingresa el número de nodos");

        inputNumNodos.setToolTipText("Ingrese el número de nodos que tendrá el grafo");

        btnCrearGrafo.setText("Crear Grafo");
        btnCrearGrafo.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btnCrearGrafoMouseClicked(evt);
            }
        });

        inputOpcionMenu.setToolTipText("Ingrese el número correspondiente a la opción que desea realizar");

        btnAceptarOpcion.setText("Aceptar");
        btnAceptarOpcion.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btnAceptarOpcionMouseClicked(evt);
            }
        });

        textAreaMenu.setColumns(20);
        textAreaMenu.setRows(5);
        jScrollPane2.setViewportView(textAreaMenu);

        jLabel1.setText("Ingresa tu Opción");

        btnRecorrido.setText("Hacer Recorrido");
        btnRecorrido.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btnRecorridoMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout panelMenuLayout = new javax.swing.GroupLayout(panelMenu);
        panelMenu.setLayout(panelMenuLayout);
        panelMenuLayout.setHorizontalGroup(
            panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelMenuLayout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 335, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelMenuLayout.createSequentialGroup()
                        .addGap(50, 50, 50)
                        .addComponent(btnAceptarOpcion, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(panelMenuLayout.createSequentialGroup()
                        .addGap(25, 25, 25)
                        .addGroup(panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btnRecorrido, javax.swing.GroupLayout.PREFERRED_SIZE, 156, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(panelMenuLayout.createSequentialGroup()
                                    .addGap(40, 40, 40)
                                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addComponent(inputOpcionMenu, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                .addContainerGap(145, Short.MAX_VALUE))
        );
        panelMenuLayout.setVerticalGroup(
            panelMenuLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelMenuLayout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(inputOpcionMenu, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(btnAceptarOpcion, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnRecorrido, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(panelMenuLayout.createSequentialGroup()
                .addComponent(jScrollPane2)
                .addContainerGap())
        );

        javax.swing.GroupLayout mainPanelLayout = new javax.swing.GroupLayout(mainPanel);
        mainPanel.setLayout(mainPanelLayout);
        mainPanelLayout.setHorizontalGroup(
            mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(mainPanelLayout.createSequentialGroup()
                .addGap(102, 102, 102)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 659, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(156, Short.MAX_VALUE))
            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(mainPanelLayout.createSequentialGroup()
                    .addGap(127, 127, 127)
                    .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(mainPanelLayout.createSequentialGroup()
                            .addComponent(lblNumNodos, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(27, 27, 27)
                            .addComponent(inputNumNodos, javax.swing.GroupLayout.PREFERRED_SIZE, 158, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(35, 35, 35)
                            .addComponent(btnCrearGrafo, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addComponent(panelMenu, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addContainerGap(85, Short.MAX_VALUE)))
        );
        mainPanelLayout.setVerticalGroup(
            mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, mainPanelLayout.createSequentialGroup()
                .addContainerGap(287, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 241, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(61, 61, 61))
            .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(mainPanelLayout.createSequentialGroup()
                    .addContainerGap()
                    .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(lblNumNodos, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(inputNumNodos, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(btnCrearGrafo, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGap(18, 18, 18)
                    .addComponent(panelMenu, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGap(319, 319, 319)))
        );

        getContentPane().add(mainPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 63, -1, 540));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnCrearGrafoMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnCrearGrafoMouseClicked
        boolean aux = false;
        try {
            numNodosGrafo = Integer.parseInt(inputNumNodos.getText());
            if (numNodosGrafo == 0) {
                JOptionPane.showMessageDialog(this, "No se puede crear un grafo con 0 nodos");
                aux = false;
            } else {
                aux = true;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Solamente números enteros");
            inputNumNodos.setText("");
            aux = false;
        }

        if (aux == true) {
            //Mostrarle al usuarios los nodos disponibles que tendra para hacer operaciones con ellos!
            //showAvailableNodes();
            textAreaResultados.setVisible(true);

            //Ocultar los componentes de soliticar numero de nodos
            lblNumNodos.setVisible(false);
            inputNumNodos.setVisible(false);
            btnCrearGrafo.setVisible(false);

            //Crear el grafo con el número de nodos indicado!
            g = new Grafo(numNodosGrafo);

            int resp = JOptionPane.showConfirmDialog(this, "¿Quieres asignarle nombre a los nodos?");
            if (JOptionPane.OK_OPTION == resp) {
                for (int i = 0; i < numNodosGrafo; i++) {
                    String nombreNodo = JOptionPane.showInputDialog(this, "Ingresa el nombre del nodo: " + i);
                    //Guardar el nombre ingresado para el nodo en la posicion actual del for!
                    nombreNodos.add(nombreNodo);
                }
            } else {
                int asciiValue = 65;
                for (int i = 0; i < numNodosGrafo; i++) {
                    char nombreNodo = (char) (asciiValue);
                    nombreNodos.add(Character.toString(nombreNodo));
                    asciiValue++;
                }
            }

            //Mostrar en el TextArea de resultados los Nodos Disponibles
            showNodesAvailable();

            int respPesos = JOptionPane.showConfirmDialog(this, "¿Asignará pesos a cada arista?");
            if (JOptionPane.OK_OPTION == respPesos) {
                asignaranPesos = true;
            } else {
                asignaranPesos = false;
            }

            int respValHeur = JOptionPane.showConfirmDialog(this, "¿Asignará valores heuristicos?");
            if (JOptionPane.OK_OPTION == respValHeur) {
                asignaranValorHeuristico = true;
            } else {
                asignaranValorHeuristico = false;
            }

            //Mostrar el menú de las opciones dle grafo!
            menu();
        }
    }//GEN-LAST:event_btnCrearGrafoMouseClicked

    private void btnAceptarOpcionMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnAceptarOpcionMouseClicked
        int opcion = 0;
        boolean aux = false;
        try {
            opcion = Integer.parseInt(inputOpcionMenu.getText());
            if (opcion > 14 || opcion <= 0) {
                JOptionPane.showMessageDialog(this, "Escoge una opción del 1 al 14");
                aux = false;
            } else {
                aux = true;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Solamente números enteros del 1 al 14");
            aux = false;
        }

        if (aux == true) {
            switch (opcion) {
                case 1:
                    changeNodeName();
                    break;
                case 2:
                    changeNodeWeight();
                    break;
                case 3:
                    changeValHeuristico();
                    break;
                case 4:
                    addArista();
                    break;
                case 5:
                    deleteArista();
                    break;
                case 6:
                    modifyArista();
                    break;
                case 7:
                    addNodo();
                    break;
                case 8:
                    deleteNodo();
                    break;
                case 9:
                    showNodesAvailable();
                    break;
                case 10:
                    deleteGraph();
                    break;
                case 11:
                    showGraph();
                    break;
                case 12:
                    getAdList();
                    break;
                case 13:
                    showMenuRecorridos();
                    break;
                case 14:
                    System.exit(0);
                    break;
            }
        }

    }//GEN-LAST:event_btnAceptarOpcionMouseClicked

    private void btnRecorridoMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnRecorridoMouseClicked

        int opcion = 0;
        boolean aux = false;
        try {
            opcion = Integer.parseInt(inputOpcionMenu.getText());
            if (opcion > 12 || opcion <= 0) {
                JOptionPane.showMessageDialog(this, "Escoge una opción del 1 al 12");
                aux = false;
            } else {
                aux = true;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Solamente números enteros del 1 al 12");
            aux = false;
        }

        if (aux == true) {
            switch (opcion) {
                case 1:
                    recorridoGuiadoPorUsuario();
                    break;
                case 2:
                    recorridoTodosLosCaminos();
                    break;
                case 3:
                    busquedaEnProfundidad();
                    break;
                case 4:
                    busquedaEnAnchura();
                    break;
                case 5:
                    busquedaPrimeroElMejor();
                    break;
                case 6:
                    busquedaAlgoritmoDijkstra();
                    break;
                case 7:
                    busquedaAlgoritmoEstrela();
                    break;
                case 8:
                    //Algoritmo búsqueda local
                    break;
                case 10:
                    showNodesAvailable();
                    menu();
                    break;
                case 11:
                    System.exit(0);
                    break;
            }
        }

    }//GEN-LAST:event_btnRecorridoMouseClicked

    private void btnOptionCreateGraphMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnOptionCreateGraphMousePressed
        try {
            int optionMakeGraph = Integer.parseInt(inputOptionCreateGraph.getText());
            if (optionMakeGraph == 1) {
                JOptionPane.showMessageDialog(this, "Se creará el grafo manualmente");
                start();
            } else if (optionMakeGraph == 2){
                JOptionPane.showMessageDialog(this, "Se cargará el grafo desde el archivo de texto");
                //String ruta = "src/analizador/datosGrafo.txt";
                //1Analizador.analizadorArchivo(ruta);
                /**
                
                * to do list:
                *   leer el archivo
                *   asignar el numero de nodos que tendrá el grafo
                *   crear los nodos

                */
                
  
                start();
                //Ocultar los campos relacionados con la captura del numero de nodos! 
                //Recordar que en el archivo que se cargará debe de estar indicado el numero de nodos que tendrá el grafo!.
                lblNumNodos.setVisible(false);
                inputNumNodos.setVisible(false);
                btnCrearGrafo.setVisible(false);
                //Mostrar el menú de las opciones dle grafo!
                menu();
            } else{
                JOptionPane.showMessageDialog(this, "Favor de ingresar solamente 1 o 2 de acuerdo a la opción con la que desea que l grafo se cree");
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Solamente números enteros");
            inputOptionCreateGraph.setText("");
        }
    }//GEN-LAST:event_btnOptionCreateGraphMousePressed
    public void start(){
        mainPanel.setVisible(true);
        //Ocultar el panel donde se muestran las opciones para crear el grafo!
        panelInicial.setVisible(false);
        //Mostrarle al usuarios los nodos disponibles que tendra para hacer operaciones con ellos!
        textAreaResultados.setVisible(true);
        //Mostrar en el TextArea de resultados los Nodos Disponibles
        showNodesAvailable();
    }//Cierre metodo start
    
    public void menu() {
        btnAceptarOpcion.setVisible(true);
        btnRecorrido.setVisible(false);
        //Mostrar el menú de opciones del programa
        panelMenu.setVisible(true);
        textAreaMenu.setText("");

        textAreaMenu.append("==== Modificar Información del Grafo ===\n");
        textAreaMenu.append("1. Cambiar Nombre a Nodo \n");
        textAreaMenu.append("2. Cambiar Peso de Arista \n");
        textAreaMenu.append("3. Cambiar Valor Heuristico \n");

        textAreaMenu.append("==== Modificar Estructura del Grafo ===\n");
        textAreaMenu.append("4. Añadir Arista \n");
        textAreaMenu.append("5. Eliminar Arista \n");
        textAreaMenu.append("6. Modificar Arista \n");

        textAreaMenu.append("=== Opciones de los Nodos ===\n");
        textAreaMenu.append("7. Añadir Nodo \n");
        textAreaMenu.append("8. Eliminar Nodo \n");
        textAreaMenu.append("9. Ver Nodos Disponibles \n");

        textAreaMenu.append("==== Opciones del Grafo ===\n");
        textAreaMenu.append("10. Eliminar Grafo \n");
        textAreaMenu.append("11. Mostrar Grafo \n");

        textAreaMenu.append("==== Lista de Adyacencia ===\n");
        textAreaMenu.append("12. Mostrar Lista de Adyacencia de un Nodo \n");

        textAreaMenu.append("==== Recorridos ===\n");
        textAreaMenu.append("13. Mostrar Opciones de Recorridos\n");

        textAreaMenu.append("==== Salir ===\n");
        textAreaMenu.append("14. Salir \n");

        inputOpcionMenu.requestFocus();
    }//Cierre metodo menu

    public void showMenuRecorridos() {
        btnAceptarOpcion.setVisible(false);
        btnRecorrido.setVisible(true);

        textAreaMenu.setText("");
        textAreaMenu.append("=======================================\n");
        textAreaMenu.append("Fase 2\n");
        textAreaMenu.append("1. Recorrido Guiado por el Usuario \n");
        textAreaMenu.append("2. Todos los Caminos Posibles \n");
        textAreaMenu.append("=======================================\n");
        textAreaMenu.append("Fase 3\n");
        textAreaMenu.append("3. Búsqueda en Profunidad \n");
        textAreaMenu.append("4. Búsqueda en Anchura \n");
        textAreaMenu.append("=======================================\n");
        textAreaMenu.append("Fase 4\n");
        textAreaMenu.append("5. Búsqueda Primero El Mejor \n");
        textAreaMenu.append("6. Búsqueda Algoritmo Dijkstra \n");
        textAreaMenu.append("=======================================\n");
        textAreaMenu.append("*** Algoritmo Heuristicos *** \n");
        textAreaMenu.append("7. Búsqueda Algoritmo A Estrella \n");
        textAreaMenu.append("8. Búsqueda Algoritmo de Búsqueda Local [Pendiente] \n");
        textAreaMenu.append("=======================================\n");
        textAreaMenu.append("Menú Opciones del Grafo \n");
        textAreaMenu.append("10. Mostrar menú de opciones para el Grafo \n");
        textAreaMenu.append("11. Salir \n");
        inputOpcionMenu.requestFocus();
    }

    public void addArista() {
        boolean condi = false;
        int v1 = askForSelectNode("Seleccione el Nodo Fuente");
        int v2 = askForSelectNode("Seleccione el Nodo Destino");
        int peso = 0;
        int heuristico = 0;

        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);

        //Si no se asignaran los pesos, por default el peso es 1 
        //y si tampoco se asignara el valor heuristico, el valor es 0
        if (asignaranPesos == false && asignaranValorHeuristico == false) {
            //Una vez que los datos esten validados correctamente invocar el metodo insertarArista de la clase Grafo
            if (g.insertaArista(v1, v2, 1, 0) == false) {
                JOptionPane.showMessageDialog(this, "Ya existe una arista entre el Nodo: " + auxNombreNodos[v1] + " y el Nodo: " + auxNombreNodos[v2]);
            } else {
                JOptionPane.showMessageDialog(this, "Arista agregada correctamente");
            }
        } else if (asignaranPesos == false && asignaranValorHeuristico == true) {
            //Si el peso no se asignara pero el valor heuristico si
            //Validar que solo se introduzcan enteros para el valor heuristico
            condi = false;
            do {
                try {
                    heuristico = Integer.parseInt(JOptionPane.showInputDialog(this, "Ingrese el valor heuristico del nodo"));
                    condi = true;
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(this, "Para el valor heuristico del nodo solamente se aceptan valores enteros");
                    condi = false;
                }
            } while (condi != true);

            if (g.insertaArista(v1, v2, 1, heuristico) == false) {
                JOptionPane.showMessageDialog(this, "Ya existe una arista entre el Nodo: " + auxNombreNodos[v1] + " y el Nodo: " + auxNombreNodos[v2]);
            } else {
                JOptionPane.showMessageDialog(this, "Arista agregada correctamente");
            }
        } else if (asignaranPesos == true && asignaranValorHeuristico == false) {
            //Si se asignara el peso pero el valor heuristico no!
            //Validar que solo se introduzcan enteros para el peso de la arista
            do {
                try {
                    peso = Integer.parseInt(JOptionPane.showInputDialog(this, "Ingresa el peso de la arista"));
                    condi = true;
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(this, "Para el peso de la arista solamente se aceptan valores enteros");
                    condi = false;
                }
            } while (condi != true);

            if (g.insertaArista(v1, v2, peso, 0) == false) {
                JOptionPane.showMessageDialog(this, "Ya existe una arista entre el Nodo: " + auxNombreNodos[v1] + " y el Nodo: " + auxNombreNodos[v2]);
            } else {
                JOptionPane.showMessageDialog(this, "Arista agregada correctamente");
            }
        } else {
            //Validar que solo se introduzcan enteros para el peso de la arista
            do {
                try {
                    peso = Integer.parseInt(JOptionPane.showInputDialog(this, "Ingresa el peso de la arista"));
                    condi = true;
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(this, "Para el peso de la arista solamente se aceptan valores enteros");
                    condi = false;
                }
            } while (condi != true);

            //Validar que solo se introduzcan enteros para el valor heuristico
            condi = false;
            do {
                try {
                    heuristico = Integer.parseInt(JOptionPane.showInputDialog(this, "Ingrese el valor heuristico del nodo"));
                    condi = true;
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(this, "Para el valor heuristico del nodo solamente se aceptan valores enteros");
                    condi = false;
                }
            } while (condi != true);

            //Insertar la arista!
            if (g.insertaArista(v1, v2, peso, heuristico) == false) {
                JOptionPane.showMessageDialog(this, "Ya existe una arista entre el Nodo: " + auxNombreNodos[v1] + " y el Nodo: " + auxNombreNodos[v2]);
            } else {
                JOptionPane.showMessageDialog(this, "Arista agregada correctamente");
            }
        }

        //Actualizar el panel donde se visualiza el grafo!
        showGraph();

    }//Cierre metodo addArista

    public void deleteArista() {
        int v1 = askForSelectNode("Seleccione el Nodo Fuente");
        int v2 = askForSelectNode("Seleccione el Nodo Destino");

        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);

        //Invocar el metodo eliminarArista de la clase Grafo
        if (g.eliminarArista(v1, v2)) {
            JOptionPane.showMessageDialog(this, "La arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2] + " fue eliminada correctamente");
            //Actualizar el panel donde se visualiza el grafo
            showGraph();
        } else {
            JOptionPane.showMessageDialog(this, "No existe una arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2]);
        }
    }//Cierre metodo deleteArista

    public boolean deleteArista(int ignore) {
        int v1 = askForSelectNode("Seleccione el Nodo Fuente");
        int v2 = askForSelectNode("Seleccione el Nodo Destino");

        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);

        //Invocar el metodo eliminarArista de la clase Grafo
        if (g.eliminarArista(v1, v2)) {
            JOptionPane.showMessageDialog(this, "La arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2] + " fue eliminada correctamente");
            return true;
        } else {
            JOptionPane.showMessageDialog(this, "No existe una arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2]);
            return false;
        }
    }//Cierre metodo deleteArista que devuelve true/false

    public void deleteGraph() {
        int input = JOptionPane.showConfirmDialog(this, "Confirma Eliminación del Grafo", "¿Seguro de eliminar el grafo?",
                JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.ERROR_MESSAGE);
        if (input == 0) {
            //Invocar el metodo liberaGrafo de la clase Grafo
            g.liberaGrafo();
            nombreNodos.clear();
            JOptionPane.showMessageDialog(this, "Grafo Eliminado");

            //Actualizar la impresion del grafo para que la eliminacion del grafo sea visible al usuario!
            showGraph();
        } else {
            JOptionPane.showMessageDialog(this, "El grafo quedo intacto");
        }

    }//Cierre metodo deleteArista

    public void showGraph() {
        textAreaResultados.setText("");
        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);
        String grafo = g.mostrarGrafo(auxNombreNodos);
        String[] showGraphInTextArea = grafo.split("-");
        for (int i = 0; i < showGraphInTextArea.length; i++) {
            textAreaResultados.append(showGraphInTextArea[i] + "\n");
        }

    }//Cierre metodo showGraph

    public void getAdList() {
        int nodoToGetAdList = askForSelectNode("Seleccione el Nodo Fuente");

        if (g.listaAdyVacia(nodoToGetAdList)) {
            JOptionPane.showMessageDialog(this, "La lista esta vacia");
        } else {
            InfoArista aux = g.getPrimerAd(nodoToGetAdList);
            textAreaResultados.setText("");
            textAreaResultados.setText("Lista adyacencia del nodo: " + nodoToGetAdList + " --->");
            while (aux != null) {
                textAreaResultados.setText(" " + aux.numVertice + ",");
                aux = g.nextAdy(aux);
            }
            textAreaResultados.setText("\n");
        }
    }

    public void changeNodeName() {
        int v = askForSelectNode("Seleccione el nodo para cambiarle el nombre");

        String newName = JOptionPane.showInputDialog(this, "Ingrese el nuevo nombre del nodo");
        //Guardar el nuevo nombre del nodo en el arrayList
        nombreNodos.set(v, newName);
        //Mostrar en el TextArea de resultados los Nodos Disponibles
        showNodesAvailable();
    }//Cierre metodo changeNodeName

    public void changeNodeWeight() {
        int v1 = askForSelectNode("Seleccione el nodo fuente de la arista a cambiar el peso");
        int v2 = askForSelectNode("Seleccione el nodo destino de la arista a cambiar el peso");

        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);

        //Validar que solo se introduzcan enteros para el peso de la arista
        boolean condi = false;
        int nuevoPeso = 0;
        do {
            try {
                nuevoPeso = Integer.parseInt(JOptionPane.showInputDialog(this, "Ingrese el nuevo peso de la arista"));
                condi = true;
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Para el peso de la arista solamente se aceptan valores enteros");
                condi = false;
            }
        } while (condi != true);
        //Invocar el metodo para cambiar el peso de la arista
        if (g.cambiarPesoArista(v1, v2, nuevoPeso)) {
            JOptionPane.showMessageDialog(this, "El peso de la arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2] + " se ha modificado correctamente");
            //Actualizar el panel donde se visualiza el grafo
            showGraph();
        } else {
            JOptionPane.showMessageDialog(this, "No existe una arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2]);
        }
    }//Cierre metodo changeNodeWeight

    public void changeValHeuristico() {
        int v1 = askForSelectNode("Seleccione el nodo fuente de la arista a cambiar el valor heuristico");
        int v2 = askForSelectNode("Seleccione el nodo destino de la arista a cambiar el valor heuristico");

        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);

        //Validar que solo se introduzcan enteros para el peso de la arista
        boolean condi = false;
        int nuevoValHeuristico = 0;
        do {
            try {
                nuevoValHeuristico = Integer.parseInt(JOptionPane.showInputDialog(this, "Ingrese el nuevo valor heuristico"));
                condi = true;
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Para el valor heuristico solamente se aceptan valores enteros");
                condi = false;
            }
        } while (condi != true);
        //Invocar el metodo para cambiar el peso de la arista
        if (g.cambiarValHeuristico(v1, v2, nuevoValHeuristico)) {
            JOptionPane.showMessageDialog(this, "El valor heuristico de la arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2] + " se ha modificado correctamente");
            //Actualizar el panel donde se visualiza el grafo
            showGraph();
        } else {
            JOptionPane.showMessageDialog(this, "No existe una arista entre el nodo: " + auxNombreNodos[v1] + " y el nodo: " + auxNombreNodos[v2]);
        }
    }//Cierre metodo changeValHeuristico

    public void modifyArista() {
        //Para modificar una arista se debe de eliminar la arista actual y agregar una nueva!
        if (deleteArista(0)) {
            JOptionPane.showMessageDialog(this, "Agrega la nueva arista");
            addArista();
        } else {
            JOptionPane.showMessageDialog(this, "Error, si no existe una arista no se puede modificar");
        }
    }//Cierre modifyArista

    public void addNodo() {
        g.agregarNodo();
        //Añadir el nombre del nuevo nodo!
        String newName = JOptionPane.showInputDialog(this, "Ingrese el nombre del nuevo nodo");
        //Guardar el nuevo nombre del nodo en el arrayList
        nombreNodos.add(newName);

        JOptionPane.showMessageDialog(this, "El nodo se agrego correctamente");
        //Mostrar en el TextArea de resultados los Nodos Disponibles
        showNodesAvailable();
    }

    public void deleteNodo() {
        int nodeToDelete = askForSelectNode("Selecciona el nodo a eliminar");
        g.eliminarNodo(nodeToDelete);
        JOptionPane.showMessageDialog(this, "El nodo se elimino correctamente");

        //Eliminar el nombre del nodo de la lista de nombres del nodo elminado!
        nombreNodos.remove(nodeToDelete);
        //Mostrar en el TextArea de resultados los Nodos Disponibles
        showNodesAvailable();
    }//Cierre metodo deleteNode

    public void showNodesAvailable() {
        textAreaResultados.setText("");
        textAreaResultados.append("Nodos Disponibles \n");
        for (int i = 0; i < nombreNodos.size(); i++) {
            textAreaResultados.append(nombreNodos.get(i) + "\n");
        }
    }//Cierre showNodesAvailable

    public int askForSelectNode(String mensaje) {
        int nodo = 0;
        //Convertir el arrayList del nombre de nodos a un array!
        String[] auxNombreNodos = nombreNodos.stream().toArray(String[]::new);

        JComboBox jcb = new JComboBox(auxNombreNodos);
        jcb.setEditable(true);

        JOptionPane.showMessageDialog(this, jcb, mensaje, JOptionPane.QUESTION_MESSAGE);

        nodo = jcb.getSelectedIndex();

        return nodo;
    }

    /*  --- Inicio Recorrido Guiado Por El Usuario --- */
    public void recorridoGuiadoPorUsuario() {
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar el camino que creao el usuario, independientemente de si llego al nodo final o no.
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tRecorrido creado por el Usuario\n");

        //Se almacenará la posición del nodo... se respeta el orden con el arraylist de los nombres de los nodos
        ArrayList<Integer> nodosVisitados = new ArrayList<Integer>();

        makePathByUser(nodoInicial, nodoFinal, nodosVisitados);

        for (int i = 0; i < nodosVisitados.size() - 1; i++) {
            textAreaResultados.append("Del nodo: " + nombreNodos.get(nodosVisitados.get(i)) + " al nodo: " + nombreNodos.get(nodosVisitados.get(i + 1)) + "\n");
        }
    }//Cierre recorridoGuiadoPorUsuario

    /*
                                        Función makePathByUser
    
        @Param1 [nodoActual]   ->   Esta variable será el nodo que usará como base para buscar sus adyacentes 
                                    cada vez que sea invocada la función...
    
        @Param2 [nodoFinal]     ->  Esta variable será siempre el mismo nodo, se usará para determinar si el recorrido ha llegado a su fin.
        
        @return                 ->  Retornará false si el recorrido creado por el usuario no pudo llegar al nodo final
                                    Retornará true solo si el recorrido que creo el usuario si pudó llegar al nodo final!
     */
    public void makePathByUser(int nodoActual, int nodoFinal, ArrayList<Integer> nodosVisitados) {
        //boolean condi = false;
        //Gurdar el nodo actual para mostrar el recorrido que realizo el usuario!
        nodosVisitados.add(nodoActual);
        //ArrayList para mostrar los nodos que el usuario tendrá disponibles una vez que haya seleccionado el nodo siguiente!
        ArrayList<InfoArista> nodosDisponibles = new ArrayList<InfoArista>();
        if (nodoActual == nodoFinal) {
            //condi = true;   
            JOptionPane.showMessageDialog(this, "Felicidades, has llegado al nodo final");
        } //Si los nodos inicio y final no son iguales... checar que la lista de adyacentes del nodo inicial no este vacia
        else if (g.listaAdyVacia(nodoActual)) {
            JOptionPane.showMessageDialog(this, "El nodo seleccionado no tiene nodos adyacentes");
            JOptionPane.showMessageDialog(this, "El camino creado no llega al nodo final");
            //condi = false;
        } //Si la lista de nodos adyacentes del nodo inicial no esta vacia, buscar y mostrar todos esos nodos al usuario para que
        //seleccione el siguiente nodo del recorrido!
        else {
            //Obtener el primer nodo adyacente de la lista!
            InfoArista aux = g.getPrimerAd(nodoActual);

            while (aux != null) {
                nodosDisponibles.add(aux);
                aux = g.nextAdy(aux);
            }
            //Ademas de que si se selecciona un nodo que no tiene adyacentes, la otra manera en la que no se logre llegar al nodo final es:
            //Que en el grafo exista un ciclo entre los nodos y el usuario nunca salga de ese cicloo....
            //Es decir, que siempre seleccione los mimos nodos, para estos casos, la unica salida sería que el usuario cancele el recorrido!
            //En el metodo showAvailableNodesTo.... se devuelve un int, a manera de validación, se devolvera un -99 cuando el usuario cancele el recorrido

            int nextNode = showAvailableNodesToContinueThePath(nodosDisponibles);

            if (nextNode == -99) {
                //Significa que el usuario cancelo el recorrido, es decir...
                //Al solicitarle el siguiente nodo clickeo la opcion de cancelar!
                JOptionPane.showMessageDialog(this, "El camino creado no llega al nodo final");
            } else {
                //De manera recursiva invocar esta función, el parametro que cambiará será el nodoInicio...
                //En cada nueva invoación, el nodoInicio será el siguiente nodo que el usuario selecciono en la iteracióna anterior!
                makePathByUser(nextNode, nodoFinal, nodosVisitados);
            }
        }
    }//Cierre makePathByUser

    /*
        @Param1     -> Recibe el arraylist de los nodos disponibles para continuar con el recorrido
        @return     -> Retorna la posición real del siguiente nodo que se selecciono para continuar con el recorrido
                       Con posición real se hace referencia a que se devuelve la posicion correspondiente de acuerdo al arraylist
                       nombreNodos.. recordar que dicho arraylist esta creado de acuerdo a los nodos del grafo!
                       es decir.... el nodo0 del grafo correspondo al nombre que esta guardado en el arraylist de nombreNodo en la posicion 0
                       y asi sucesivamente!
     */
    public int showAvailableNodesToContinueThePath(ArrayList<InfoArista> nodosDisponibles) {
        //Convertir el arrayList de nodosDisponibles a un array
        InfoArista[] auxNodosDisponibles = nodosDisponibles.stream().toArray(InfoArista[]::new);

        ArrayList<String> nombreNodosDisponibles = new ArrayList<String>();

        //Obtener el nombre de los nodos disponibles de acuerdo al numero de vertice, se obtienen del arraylist nombreNodos
        for (int i = 0; i < auxNodosDisponibles.length; i++) {
            nombreNodosDisponibles.add(nombreNodos.get(auxNodosDisponibles[i].numVertice));
        }

        //Convertir el arrayList del nombre de nodos disponibles a un array!
        String[] auxNombreNodosDisponibles = nombreNodosDisponibles.stream().toArray(String[]::new);

        JComboBox jcb = new JComboBox(auxNombreNodosDisponibles);
        jcb.setEditable(true);
        //Mostrarle al usuario los nodos disponibles para continuar con el recorrido!
        int ans = JOptionPane.showConfirmDialog(this, jcb, "Siguiente nodo a visitar", JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (ans == JOptionPane.OK_OPTION) {
            int nextNodeSelected = jcb.getSelectedIndex();

            int nextNode = 0;
            //Obtener la posición correspondiente del siguiente nodo en la lista de nombres de nodos!
            for (int i = 0; i < nombreNodos.size(); i++) {
                if (nombreNodosDisponibles.get(nextNodeSelected) == nombreNodos.get(i)) {
                    nextNode = i;
                }
            }
            return nextNode;
        } else {
            JOptionPane.showMessageDialog(this, "Haz cancelado el recorrido");
            return -99;
        }
    }//Cierre metodo showAvailableNodesToContinueThePath

    /*  --- Fin Recorrido Guiado Por El Usuario --- */

 /*  --- Inicio Métodos para el algoritmo de obtener todos los caminos posibles  --- */
    public void recorridoTodosLosCaminos() {
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar el camino que creao el usuario, independientemente de si llego al nodo final o no.
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tTodos los caminos posibles \n\n");

        TodosLosCaminos objAuxTodosLosCaminos = new TodosLosCaminos();
        //Invocar al metodo para obtener todos los caminos posibles y almacenarlos en una arraylist de arraylist<Integer>
        ArrayList<ArrayList<Integer>> caminos = objAuxTodosLosCaminos.getAllPaths(nodoInicial, nodoFinal, g);

        //Imprimir los caminos obtenidos
        if (caminos.isEmpty()) {
            System.out.println("No existe ningún camino");
        } else {
            for (int i = 0; i < caminos.size(); i++) {
                //Cada camino separarlo en un ArrayList<Integer> para poder convertir los numeros a los nombres de los nodos e imprimir los nombres de los nodos!
                ArrayList<Integer> aux = caminos.get(i);
                textAreaResultados.append("*** Camino: " + (i + 1) + " ***\n");
                for (int z = 0; z < aux.size() - 1; z++) {
                    textAreaResultados.append("\tDel nodo: " + nombreNodos.get(aux.get(z)) + " al nodo: " + nombreNodos.get(aux.get(z + 1)) + "\n");
                }
                textAreaResultados.append("\n");
            }
        }
    }//Cierre recorridoTodosLosCaminos

    /*  --- Fin Métodos para el algoritmo de obtener todos los caminos posibles  --- */
 /*  --- Inicio Algoritmos Fase 3   -> Busquedas No Guíadas [El peso no importa] ---  */
    public void busquedaEnProfundidad() {
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar los nodos inicio y final al usuario!
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tRecorrido creado usando el Algoritmo Búsqueda en Profundidad\n");

        BusquedaEnProfundidad objAuxBusquedaEnProfundidad = new BusquedaEnProfundidad();
        //Invocar al metodo que realiza el algoritmo de busqueda en profundidad
        ArrayList<Integer> camino = objAuxBusquedaEnProfundidad.algoritmoBusquedaEnProfundidad(nodoInicial, nodoFinal, g);

        //Imprimir el camino encontrado
        //Presentar el camino de inicio a fin
        for (int i = camino.size() - 1; i > 0; i--) {
            textAreaResultados.append("\tDel nodo: " + nombreNodos.get(camino.get(i)) + " al nodo: " + nombreNodos.get(camino.get(i - 1)) + "\n");
        }
    }//Cierre busquedaEnProfundidad

    public void busquedaEnAnchura() {
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar los nodos inicio y final al usuario!
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tRecorrido creado usando el Algoritmo Búsqueda en Anchura\n");

        BusquedaEnAnchura objAuxBusquedaEnAnchura = new BusquedaEnAnchura();
        //Invocar al metodo que realiza el algoritmo de busqueda en anchura
        ArrayList<Integer> camino = objAuxBusquedaEnAnchura.algoritmoBusquedaEnAnchura(nodoInicial, nodoFinal, g);

        //Imprimir el camino creado
        //Presentar el camino de inicio a fin
        for (int i = camino.size() - 1; i > 0; i--) {
            textAreaResultados.append("\tDel nodo: " + nombreNodos.get(camino.get(i)) + " al nodo: " + nombreNodos.get(camino.get(i - 1)) + "\n");
        }
    }//Cierre busquedaEnAnchura

    /*  --- Fin Algoritmos Fase 3   -> Busquedas No Guíadas [El peso no importa]  ---  */

 /*  --- Inicio Algoritmos Fase 4   -> Busquedas Guíadas [El peso si importa]  ---  */
    public void busquedaPrimeroElMejor() {
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar los nodos inicio y final al usuario!
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tRecorrido creado usando el Algoritmo Búsqueda Primero el Mejor\n");

        PrimeroElMejor objAuxPrimeroElMejor = new PrimeroElMejor();
        //Invocar al metodo que realiza el algoritmo de busqueda Primero el Mejor
        ArrayList<Integer> camino = objAuxPrimeroElMejor.busquedaPrimeroElmejor(nodoInicial, nodoFinal, g);

        //Presentar el camino de inicio a fin
        for (int i = camino.size() - 1; i > 0; i--) {
            textAreaResultados.append("\tDel nodo: " + nombreNodos.get(camino.get(i)) + " al nodo: " + nombreNodos.get(camino.get(i - 1)) + "\n");
        }

        //Mostrar el costo total de recorrer el camino
        int costoTotal = objAuxPrimeroElMejor.getCostoTotal();
        textAreaResultados.append("\n\tEl costo total del camino es: " + costoTotal);
    }//Cierre busquedaPrimeroElMejor

    public void busquedaAlgoritmoDijkstra() {
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar los nodos inicio y final al usuario!
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tRecorrido creado usando el Algoritmo de Dijkstra\n");

        AlgoritmoDijkstra objAuxAlgoritmoDijkstra = new AlgoritmoDijkstra();
        //Invocar el metodo para obtener el camino utilizando el Algoritmo de Dijkstra
        ArrayList<Integer> camino = objAuxAlgoritmoDijkstra.algoritmoDijkstra(nodoInicial, nodoFinal, g);
        
        for (int i = camino.size() - 1; i > 0; i--) {
            //System.out.println("Del nodo: " + auxCamino.get(i) + " al nodo: " + auxCamino.get(i - 1));
            textAreaResultados.append("\tDel nodo: " + nombreNodos.get(camino.get(i)) + " al nodo: " + nombreNodos.get(camino.get(i - 1)) + "\n");
        }

        //Mostrar el costo total de recorrer el camino
        int costoTotal = objAuxAlgoritmoDijkstra.getCostoTotal();
        textAreaResultados.append("\n\tEl costo total del camino es: " + costoTotal);
    }//Cierre busquedaAlgoritmoDijkstra
    
    /*  --- Fin Algoritmos Fase 4   -> Busquedas Guíadas [El peso si importa]  ---  */
    
    /*  --- Inicio Algoritmos Heuristicos  ---  */
    
    public void busquedaAlgoritmoEstrela(){
        int nodoInicial = askForSelectNode("Ingresa el nodo inicial");
        int nodoFinal = askForSelectNode("Ingresa el nodo final");

        //Mostrar los nodos inicio y final al usuario!
        textAreaResultados.setText("");
        textAreaResultados.append("Nodo Inicial: " + nombreNodos.get(nodoInicial) + "\n");
        textAreaResultados.append("Nodo Final: " + nombreNodos.get(nodoFinal) + "\n");
        textAreaResultados.append("\tRecorrido creado usando el Algoritmo A Estrella \n");
        
        Algoritmo_A_Estrella objAuxAlgoritmoEstrella = new Algoritmo_A_Estrella();
        //Invocar el metodo para obtener el camino utilizando el Algoritmo de Dijkstra
        ArrayList<Integer> camino = objAuxAlgoritmoEstrella.algoritmoEstrella(nodoInicial, nodoFinal, g);
        
        for (int i = camino.size() - 1; i > 0; i--) {
            //System.out.println("Del nodo: " + auxCamino.get(i) + " al nodo: " + auxCamino.get(i - 1));
            textAreaResultados.append("\tDel nodo: " + nombreNodos.get(camino.get(i)) + " al nodo: " + nombreNodos.get(camino.get(i - 1)) + "\n");
        }

        //Mostrar el costo total de recorrer el camino
        int costoTotal = objAuxAlgoritmoEstrella.getCostoTotal();
        textAreaResultados.append("\n\tEl costo total del camino es: " + costoTotal);
        
    }//Cierre busquedaAlgoritmoEstrella
    
    /*  --- Fin Algoritmos Heuristicos  ---  */
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAceptarOpcion;
    private javax.swing.JButton btnCrearGrafo;
    private javax.swing.JButton btnOptionCreateGraph;
    private javax.swing.JButton btnRecorrido;
    private javax.swing.JTextField inputNumNodos;
    private javax.swing.JTextField inputOpcionMenu;
    private javax.swing.JTextField inputOptionCreateGraph;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel lblNumNodos;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JPanel panelInicial;
    private javax.swing.JPanel panelMenu;
    private javax.swing.JTextArea textAreaMenu;
    private javax.swing.JTextArea textAreaResultados;
    // End of variables declaration//GEN-END:variables
}
